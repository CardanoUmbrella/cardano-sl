\documentclass{article}
\usepackage[margin=2.5cm]{geometry}
\usepackage{amsmath, amssymb, stmaryrd, latexsym, amsthm}
\usepackage{mathpazo, times}
\usepackage{float}
\usepackage{listings}
\usepackage{url}
\usepackage{natbib}
\usepackage{parskip}
\usepackage{todonotes}
\usepackage{slashed}
\usepackage{tikz}
\usepackage{forest}

\newcommand{\powerset}[1]{\mathbb{P}(#1)}
\newcommand{\order}[1]{\mathcal{O}\left(#1\right)}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\range}{range}
\newcommand{\restrictdom}{\lhd}
\newcommand{\subtractdom}{\mathbin{\slashed{\restrictdom}}}
\newcommand{\restrictrange}{\rhd}

\newtheorem{proofobligation}{Proof Obligation}
\newtheorem{lemma}{Lemma}
\newtheorem{invariant}{Invariant}
\newtheorem{definition}{Definition}

\floatstyle{boxed}
\restylefloat{figure}

\lstset{basicstyle=\ttfamily\small}

\begin{document}

\title{Cardano wallet specification (DRAFT)}
\author{Duncan Coutts \and Edsko de Vries}
\date{March 5, 2018}

\maketitle

\section*{Status}

\begin{description}
\item[Draft 0, Jan 18, 2018 (Duncan)] Various scraps of paper
\item[Draft 1, Jan 24, 2018 (Duncan)] Presented to Alfredo Di Napoli, Philipp Kant,
     Edsko de Vries and Bruno Woltzenlogel Paleo.
\item[Draft 2, Jan 25, 2018 (Duncan)] Incorporated feedback from Edsko de Vries,
     Bruno Woltzenlogel Paleo and Kristijan \v{S}ari\'{c}. Fixed UTxO
     definition. Presented to Edsko de Vries.
\item[Draft 3, Jan 26, 2018 (Duncan)] Incorporated feedback from Edsko de Vries.
     Simplified presentation of change and txins/txouts. Described updateUTxO.
\item[Draft 4, Jan 31, 2018 (Duncan)] Added section on efficiency and incrementally
     maintaining the balances. Presented at the Well-Typed weekly seminar and
     incorporated feedback from Andres L\"oh and Edsko de Vries.
\item[Draft 5, Feb 2, 2018 (Duncan)] Completed section on incrementally maintaining the
     balances. Slight notation change. Lemmas, invariants and assumptions
     clarified. Next steps updated.
\item[Draft 6, Feb 12, 2018 (Edsko)] Added section on prefiltering.
\item[Draft 7, Feb 14, 2018 (Edsko)] Added section on rollbacks.
\item[Draft 8, Feb 27, 2018 (Edsko)] Fixed definition of prefiltering in the presence
     of rollbacks, and made the style more consistent with Duncan's.
\item[Draft 9, Mar 5, 2018 (Edsko)] First stab at clarifying the computation and
     presentation of the wallet's balance in the presence of rollbacks.
\item[Draft 10, Mar 16, 2018 (Duncan)] First sketch of input selection
\item[Draft 11, Mar 19, 2018 (Edsko)] Computation of minimum balance
\end{description}

\section{Introduction}

This document is intended to be a plausible abstract description of a wallet
for Cardano (or any UTxO-based cryptocurrency). The purpose is to help
understand some of the subtleties and give a reasonable starting point for
tests and implementations.

To my knowledge, there is no pre-existing abstract wallet specification so the
design approach taken here has been to fiddle around to try and find something
self-consistent, simple and plausible, and also to try to establish high level
properties that correspond to our intuition of what a wallet is. This is to try
to give us some confidence that this is not just a collection of definitions
and rules, but a collection that does correspond to what we believe a wallet is
or does.

\section{Basic definitions}

These definitions are intended be compatible with the presentation by
\cite{utxo_accounting}.

A \emph{transaction}, ranged over by $tx \in \mathsf{Tx}$, is a tuple
$(inputs, outputs)
   \in \powerset{\mathsf{TxIn}}
   \times (\mathsf{Ix} \mapsto \mathsf{TxOut})$.

There is a function $\mathsf{txid} \in \mathsf{Tx} \to \mathsf{TxId}$ that gives
the transaction id for any transaction. This is assumed to be ``effectively''
injective\footnote{A quick counting argument shows this is impossible, given
finite representations. The assumption is justified on the basis that we use
cryptographically strong hash functions so that computing clashes is
computationally impractical.} so that a transaction id uniquely identifies a
transaction.

A \emph{transaction id} is a value $txid \in \mathsf{TxId}$. The set of
transaction ids $\mathsf{TxId}$ is a large finite set of distinct values with
no interesting operations.

A \emph{transaction input}, ranged over by $txin \in \mathsf{TxIn}$, is a tuple
$(txid, ix) \in \mathsf{TxId} \times \mathsf{Ix}$.

A \emph{transaction output}, ranged over by $txout \in \mathsf{TxOut}$, is a tuple
$(addr, c) \in \mathsf{Addr} \times \mathsf{Coin}$.

Indexes $ix \in \mathsf{Ix}$ are used to index transaction outputs. These will
typically be natural numbers, but this is not necessary.

\emph{Addresses} $addr \in \mathsf{Addr}$ stand for cryptographic public keys. In this
presentation we can keep them quite abstract, it is merely a large set of
distinct values.

Currency values $c \in \mathsf{Coin}$ are numeric values supporting 0 and addition.

There is a predicate $\mathsf{ours} \in \mathsf{Addr} \to \mathbb{B}$
that tells us if a particular address ``belongs'' to our wallet.
This corresponds in the real implementation to us being able to identify
addresses that correspond to our wallet where we can derive the keypair used
to generate that address, and to sign transactions that pay from that address.
If it aids comprehension, it may be worth noting that if this specification
were elaborated to cover public/private key pairs, then we would model this as
a partial function that returns the keypair as evidence
$\mathsf{ours} \in \mathsf{Addr} \mapsto (\mathsf{PubKey} \times \mathsf{PrivKey})$.

Equivalent to the predicate $\mathsf{ours}$, we define a set
$\mathsf{Addr_{ours}} = \{ a ~|~ a \in Addr, ~ \mathsf{ours} ~ a \}$ and
similarly a set
$\mathsf{TxOut_{ours}} = \mathsf{Addr_{ours}} \times \mathsf{Coin}$. These are
the total range of addresses or transaction outputs that our wallet is
interested in.

The wallet \emph{unspent transaction outputs}, ranged over by
$utxo \in \mathsf{UTxO}$, is a mapping $\mathsf{TxIn} \mapsto \mathsf{TxOut}$.
The intuition of this is that it records all the transaction inputs in our
wallet that we have available to spend from, and how much cash is available at
each one. We will see in how it is constructed that it is derived solely from
the chain, and not any other wallet state. Note also that this will only cover
our wallet, i.e. range within $\mathsf{TxOut_{ours}}$, and not the UTxO of the
entire blockchain.

The wallet \emph{pending transactions}, ranged over by
$pending \in \mathsf{Pending}$, is a set of transactions
$tx \in pending \in \powerset{\mathsf{Tx}}$.

The \emph{wallet state}, ranged over by $w \in \mathsf{Wallet}$, is a tuple
$(utxo, pending) \in \mathsf{UTxO} \times \mathsf{Pending}$.

A \emph{block} (in a blockchain), ranged over by $b \in \mathsf{Block}$, is a
set of transactions $tx \in b \in \powerset{\mathsf{Tx}}$.

Of course our usual intuition is that a block is a sequence of transactions,
not a set, so one may wonder at this choice. For \emph{validating} a block it
is essential to represent it as a sequence, but a wallet does not need to
validate blocks; it can rely on its associated node to do that. The order of
transactions in a block does not turn out to matter for any wallet operation,
and the choice of set representation makes it possible to share useful
operations between the set of pending transactions and the set of transactions
in a block.

\section{Wallet operations}
\label{sec:wallet_operations}

There are only a small number of wallet operations of interest. We can:
\begin{itemize}
\item enquire as to the balance of the wallet (total balance and
      available balance).
\item make a new wallet state by "applying" a block to a wallet state
\item make a new wallet state by adding a new pending transaction to a wallet
      state
\end{itemize}

\begin{equation}
\begin{split}
\mathsf{totalBalance}     & \in \mathsf{Wallet} \to \mathsf{Coin} \\
\mathsf{availableBalance} & \in \mathsf{Wallet} \to \mathsf{Coin} \\
\mathsf{applyBlock}       & \in \mathsf{Block} \to \mathsf{Wallet}
                                             \to \mathsf{Wallet} \\
\mathsf{newPending}       & \in \mathsf{Tx} \to \mathsf{Wallet}
                                          \to \mathsf{Wallet}
\end{split}
\end{equation}

Many arguments will be by induction on the structure of how a wallet can be
built, i.e. combinations of $\mathsf{applyBlock}$ and $\mathsf{newPending}$.
For a base case we need the empty wallet value.

\begin{equation}
\begin{split}
w_\emptyset & \in \mathsf{Wallet} \\
w_\emptyset & = (\emptyset, \emptyset)
\end{split}
\end{equation}

It is worth mentioning that in the real implementation we have another
operation, $\mathsf{undoBlock}$ which is in some sense the inverse of
$\mathsf{applyBlock}$. We will revisit this operation later.

%\begin{equation}
%\begin{split}
%\mathsf{undoBlock} \in \mathsf{Block} \to \mathsf{Wallet} \to \mathsf{Wallet} \\
%\forall ~ w ~ b. ~ \mathsf{undoBlock} ~ b ~ (\mathsf{applyBlock} ~ b ~ w) = w
%\end{split}
%\end{equation}

\subsection{Notation}

\subsubsection{Domain and Range Restriction}

We make use of the somewhat-standard notation for domain and range restriction
operators on functions (or more generally relations).

\begin{equation*}
\begin{split}
a \restrictdom  f  & = \{ x \mapsto y ~|~ x \mapsto y \in f, ~ x \in a \} \\
f \restrictrange a  & = \{ x \mapsto y ~|~ x \mapsto y \in f, ~ y \in a \}
\end{split}
\end{equation*}

The more common notation for a function domain restriction $a \restrictdom f$
is $f \restriction a$, but we use this notation for symmetry with the range
restriction $f \restrictrange a$.

\subsubsection{Domain Exclusion}

It is convenient to use an operator $f \subtractdom s$, that restricts the
domain of the function to \emph{exclude} elements of a given set. This is a
normal function domain restriction but with the membership condition inverted.
So we can use either of the following definitions.

\begin{equation*}
\begin{split}
a \subtractdom f  & = ( \dom f \setminus a ) \restrictdom f \\
a \subtractdom f  & = \{ x \mapsto y ~|~ x \mapsto y \in f, ~ x \notin a \}
\end{split}
\end{equation*}

\subsubsection{Properties}

Domain restriction distributions over union:
%
\begin{equation} \label{restrictdom_union}
\begin{split}
& a \restrictdom (u \cup v) \\
= & \{ x \mapsto y ~|~ x \mapsto y \in (u \cup v), x \in a \} \\
= & \{ x \mapsto y ~|~ (x \mapsto y \in u) \vee (x \mapsto y \in v), x \in a \} \\
= & \{ x \mapsto y ~|~ (x \mapsto y \in u, x \in a) \vee (x \mapsto y \in v, x \in a) \} \\
= & \{ x \mapsto y ~|~ x \mapsto y \in u, x \in a \} \cup \{ x \mapsto y ~|~ x \mapsto y \in v, x \in a \} \\
= & (a \restrictdom u) \cup (a \restrictdom v)
\end{split}
\end{equation}
%
and similarly for domain exclusion
%
\begin{equation} \label{subtractdom_union}
a \subtractdom (u \cup v) = (a \subtractdom u) \cup (a \subtractdom v)
\end{equation}

Both domain restriction and exclusion affect the domain only:
%
\begin{align}
(a \cap \dom u) \restrictdom u & = a \restrictdom u \label{restrictdom_dom} \\
(a \cap \dom u) \subtractdom u & = a \subtractdom u \label{subtractdom_dom}
\end{align}

\todo[inline]{Use consistent variable naming.}

\subsection{Helpful operations}

Before we define the main operations listed above, it is helpful to define some
extra operations.

\begin{equation}
\begin{split}
\mathsf{txins}& \in \powerset{\mathsf{Tx}} \to \powerset{\mathsf{TxIn}} \\
\mathsf{txins}& ~ txs = \bigcup \{ inputs ~|~ (inputs, \_) \in txs \}
\end{split}
\end{equation}

\begin{equation}
\begin{split}
\mathsf{txouts}&\in \powerset{\mathsf{Tx}} \to \mathsf{UTxO} \\
\mathsf{txouts}& ~ txs =
  \left\{ (\mathsf{txid} ~ tx, ix) \mapsto txout ~
  \middle| \begin{array}{l@{~}c@{~}l}
             tx & \in & txs \\
             (\_, outputs) & = & tx \\
             ix \mapsto txout & \in & outputs
           \end{array}
  \right\}
\end{split}
\end{equation}

\begin{equation}
\begin{split}
\mathsf{available}, \mathsf{change}, \mathsf{total} & \in \mathsf{Wallet} \to \mathsf{UTxO} \\
\mathsf{available} ~ (utxo, pending) & = \mathsf{txins} ~ pending \subtractdom utxo \\
\mathsf{change} ~ (utxo, pending) & =
    \mathsf{txouts} ~ pending \restrictrange \mathsf{TxOut_{ours}} \\
\mathsf{total} ~ w & = \mathsf{available} ~ w \cup \mathsf{change} ~ w \\
\end{split}
\end{equation}

\begin{equation}
\begin{split}
\mathsf{balance}& \in \mathsf{UTxO} \to \mathsf{Coin} \\
\mathsf{balance}& ~ utxo = \sum_{(\_ ~ \mapsto (\_, c)) \in utxo} c
\end{split}
\end{equation}

\subsection{Main operations}
\label{sec:main_operations}

\begin{equation}
\begin{split}
\mathsf{availableBalance} & = \mathsf{balance} \circ \mathsf{available} \\
\mathsf{totalBalance}     & = \mathsf{balance} \circ \mathsf{total}
\end{split}
\end{equation}

These two are nice and simple once we define the available and total UTxO. It
is simply the available coins in those two UTxOs.

\begin{equation} \label{applyBlock_spec}
\begin{split}
\mathsf{applyBlock} & ~ b ~ (utxo, pending) = \\
                    & (\mathsf{updateUTxO} ~ b ~ utxo, ~~ \mathsf{updatePending} ~ b ~ pending)
\end{split}
\end{equation}

\begin{equation}
\begin{split}
\mathsf{updateUTxO} & \in \mathsf{Block} \to \mathsf{UTxO} \to \mathsf{UTxO} \\
\mathsf{updateUTxO} & ~ b ~ utxo = \mathsf{txins} ~ b \subtractdom (utxo \cup (\mathsf{txouts} ~ b \restrictrange \mathsf{TxOut_{ours}}))
\end{split}
\end{equation}

Note in this definition that we must remove spent inputs from the block after
adding the extra outputs. It would be incorrect to use the definition $(\mathsf{txins} ~ b \subtractdom utxo)  \cup (\mathsf{txouts} ~ b \restrictrange \mathsf{TxOut_{ours}})$.
The difference of course crops up when one considers transactions within the
block $b$ that depend on each other: that is where the output of one transaction
is used as the input of another within the same block.

\begin{equation}
\begin{split}
\mathsf{updatePending} & \in \mathsf{Block} \to \mathsf{Pending} \to \mathsf{Pending} \\
\mathsf{updatePending} & ~ b ~ p = \{ tx ~|~ tx \in p, (inputs, \_) = tx, inputs \cap \mathsf{txins} ~ b = \emptyset \}
\end{split}
\end{equation}

This is the ``ah hah'' moment, that this bit can be made so simple. Note that
this covers the case of one of our own transactions being committed, as well as
transactions submitted by other instances of our wallet invalidating our
pending transactions. Both are covered because all we are doing is removing
pending transactions that have had any (or all!) of their inputs spent.

\begin{equation}
\begin{split}
\mathsf{newPending} & ~ tx ~ (utxo, pending) = ( utxo, ~~ pending \cup \{ tx \} ) \\
                    & \text{if } (inputs, \_) = tx \\
                    & \quad inputs \subseteq \dom (\mathsf{available} ~ (utxo, pending))
\end{split}
\end{equation}

Note the side condition on $\mathsf{newPending}$. If we changed this to
$inputs \subseteq \dom (\mathsf{total}(utxo, pending))$ then we would allow transactions
that spend from change addresses, allowing multiple in-flight transactions
that depend on each other. It's not immediately obvious if this would be a
purely local change or if there are other knock-on consequences.

Note from the definitions of $\mathsf{applyBlock}$ and $\mathsf{newPending}$
(and by induction from $w_\emptyset$) that the wallet UTxO depends only on the
blocks and not the pending transactions.



\section{Assumptions and properties}

\subsection{Assumptions}

For $\mathsf{applyBlock}$ we have an assumption, that should be a
straightforward property of the blockchain. Much like the two properties above
it simply says that new transactions in a new block should have transaction
ids that do not occur in the utxo of the existing chain (or wallet).

\begin{equation} \label{applyBlock_assumption}
\begin{split}
\mathsf{applyBlock} & ~ b ~ (utxo, pending) = \ldots \\
& \text{if } \dom (\mathsf{txouts} ~ b) \cap \dom utxo = \emptyset \\
\end{split}
\end{equation}


\subsection{Lemmas}

There are a couple useful lemmas about $\mathsf{balance}$ distributing over
other operators.

\begin{equation} \label{lemma_balance_minus}
  \dom a \cap \dom b = \emptyset \quad \Longrightarrow \quad
  \mathsf{balance} ~ (a \cup b) = \mathsf{balance} ~ a + \mathsf{balance} ~ b
\end{equation}

\begin{equation} \label{lemma_balance_union}
  \mathsf{balance} ~ (a \subtractdom f) = \mathsf{balance} ~ f - \mathsf{balance} ~ (a \restrictdom f) \\
\end{equation}


\subsection{Invariants}
\label{sec:invariants}

We would hope to prove the following invariants are true for all wallet values

\begin{equation} \label{txins_in_dom_utxo}
\mathsf{txins} ~ pending \subseteq \dom utxo
\end{equation}

Note that this is only true if we do not allow dependent in-flight transactions.
If we do allow dependent ones then the spent set of the pending includes change
addresses that are not yet in the wallet UTxO.

Note that we may need to revisit this invariant in the light of rollbacks,
because that reverts the UTxO but the set of pending transactions is not.

\begin{equation}
\range utxo \subseteq \mathsf{TxOut_{ours}}
\end{equation}

This just says that our wallet UTxO only covers addresses that belong to us,
without covering anyone else's addresses.

\begin{equation} \label{change_vs_available}
\dom (\mathsf{change} ~ w) \cap \dom (\mathsf{available} ~ w) = \emptyset
\end{equation}

\begin{equation} \label{change_vs_utxo}
\dom (\mathsf{change} ~ w) \cap \dom utxo = \emptyset
\end{equation}

This is not very deep. All new transactions should have fresh ids, and thus
not be in the existing wallet UTxO. The first one reminds us that once
transactions make it into the UTxO, they have been removed from the pending set.

And some high level properties corresponding to our intuition, for a wallet $w$:

\begin{equation}
\begin{split}
\mathsf{change} ~ w \cup \mathsf{available} ~ w &= \mathsf{total} ~ w \\
\mathsf{balance} ~ (\mathsf{change} ~ w) + \mathsf{balance} ~ (\mathsf{available} ~ w) &= \mathsf{balance} ~ (\mathsf{total} ~ w)
\end{split}
\end{equation}

Of course the first is actually a definition. The second follows from the
first plus lemma \ref{lemma_balance_union} with invariant \ref{change_vs_available}


\section{Efficiency considerations}

The description above is intended to be simple, not efficient. Let us take the
initial description as a na\"ive implementation and consider the asymptotic
complexity of the major operations. Then we can explore other approaches with
better asymptotic complexity.

Many of the basic operations we need to consider are set and map operations
implemented using ordered balanced trees. Many of these operations have the
following complexity, where $M$ and $N$ are the sizes of the two sets or maps.

\begin{equation*}
\begin{split}
\mathsf{nlogn} ~ N & = N \cdot \log N \\
\mathsf{join} ~ M ~ N & = M \cdot \log ~ (N/M + 1) \quad \text{for } M \leq N
\end{split}
\end{equation*}

The complexity of the major operations are then

\begin{equation*}
\begin{split}
\mathsf{balance} ~ u & \in \order{|u|} \\
\mathsf{txins}   ~ txs  & \in \order{\mathsf{nlogn} ~ |\mathsf{txins}~ txs|} \\
\mathsf{txouts}  ~ txs  & \in \order{\mathsf{nlogn} ~ |\mathsf{txouts}~ txs|)} \\
\mathsf{available} ~ (u,p) & \in \order{\mathsf{join} ~ |\mathsf{txins}~ p| ~ |u|} \\
\mathsf{change}    ~ (u,p) & \in \order{\mathsf{nlogn} ~ |\mathsf{txouts}~ p| } \\
\mathsf{total}     ~ (u,p) & \in \order{
                              \begin{split}
                                & ~ \mathsf{join} ~ |\mathsf{txins}~ p| ~ |u| \\
                              + & ~ \mathsf{join} ~ |\mathsf{txouts}~ p| ~ |u| \\
                              + & ~ \mathsf{nlogn} ~ |\mathsf{txouts}~ p|
                              \end{split}} \\
\mathsf{availableBalance} ~ (u,p) & \in \order{
                              \begin{split}
                                & ~ |u| \\
                              + & ~ \mathsf{join} ~ |\mathsf{txins}~ p| ~ |u|
                              \end{split}} \\
\mathsf{totalBalance}     ~ (u,p) & \in \order{
                              \begin{split}
                                & ~ |u| \\
                              + & ~ \mathsf{join} ~ |\mathsf{txins}~ p| ~ |u| \\
                              + & ~ \mathsf{join} ~ |\mathsf{txouts}~ p| ~ |u| \\
                              + & ~ \mathsf{nlogn} ~ |\mathsf{txouts}~ p|
                              \end{split}} \\
\mathsf{newPending} ~ tx ~ (u,p) & \in \order{\log |p|} \\
\mathsf{updateUTxO} ~ b ~ u & \in \order{
                              \begin{split}
                                & ~ \mathsf{join} ~ |\mathsf{txins}~ b| ~ |u| \\
                              + & ~ \mathsf{join} ~ |\mathsf{txouts}~ b| ~ |u|
                              \end{split}} \\
\mathsf{updatePending} ~ b ~ p & \in \order{\mathsf{nlogn} ~ |\mathsf{txins}~ b| + \sum_{(inputs, \_) \in p}{\mathsf{join} ~ |inputs| ~ |\mathsf{txins}~ b|}}
\end{split}
\end{equation*}

It is worth knowing that the expected order of magnitudes of the sizes of the
utxo and pending sets. The UTxO can be quite large, for example
$|utxo| \leq 10^6$, while the pending set will typically be small, usually
around $|pending| \leq 3$, while $|pending| = 100$ would be extreme. Similarly,
the number of inputs and outputs in any individual transaction is not large.

The asymptotic complexity of the na\"ive implementations are in fact mostly
good enough. If we assume that the number of pending transactions, and the
number of inputs and outputs for individual transactions is not large,
then the only problematic operations are $\mathsf{availableBalance}$ and
$\mathsf{totalBalance}$, which are both linear in $|u|$ (the size of the UTxO).

\subsection{Computing the balances}

Suppose we have a wallet state $(utxo, pending)$, with

\begin{equation*}
\begin{split}
a & = \mathsf{availableBalance} ~ (utxo, pending) \\
t & = \mathsf{totalBalance} ~ (utxo, pending)
\end{split}
\end{equation*}
Expanding definitions we have
\begin{equation*}
\begin{split}
a & = \mathsf{balance} ~ (\mathsf{available} ~ (utxo, pending)) \\
t & = \mathsf{balance} ~ (\mathsf{available} ~ (utxo, pending) \cup \mathsf{change} ~ (utxo, pending))
\end{split}
\end{equation*}

We will use lemma \ref{lemma_balance_union}, about $\mathsf{balance}$
distributing over $\cup$. The lemma's antecedent is satisfied by invariant
\ref{change_vs_available}. So this gives us
\begin{equation*}
\begin{split}
a & = \mathsf{balance} ~ (\mathsf{available} ~ (utxo, pending)) \\
t & = \mathsf{balance} ~ (\mathsf{available} ~ (utxo, pending)) \\
  & + \mathsf{balance} ~ (\mathsf{change} ~ (utxo, pending))
\end{split}
\end{equation*}

Expanding definitions and simplifying we get

\begin{equation*}
\begin{split}
a & = \mathsf{balance} ~ (\mathsf{txins} ~ pending \subtractdom utxo) \\
t & = a + \mathsf{balance} ~ (\mathsf{txouts} ~ pending \restrictrange \mathsf{TxOut_{ours}})
\end{split}
\end{equation*}

Next we apply lemma \ref{lemma_balance_minus} to distribute $\mathsf{balance}$
over $\subtractdom$, to get

\begin{equation*}
\begin{split}
a & = \mathsf{balance} ~ utxo - \mathsf{balance} ~ (\mathsf{txins} ~ pending \restrictdom utxo) \\
t & = a + \mathsf{balance} ~ (\mathsf{txouts} ~ pending \restrictrange \mathsf{TxOut_{ours}})
\end{split}
\end{equation*}

Note the complexity of these operations

\begin{equation*}
\begin{split}
\mathsf{balance} ~ utxo & \in \order{|utxo|} \\
\mathsf{balance} ~ (\mathsf{txins} ~ pending \restrictdom utxo) & \in \order{\mathsf{join} ~ |\mathsf{txins}~ pending| ~ |utxo|} \\
\mathsf{balance} ~ (\mathsf{txouts} ~ pending \restrictrange \mathsf{TxOut_{ours}}) & \in \order{\mathsf{nlogn} ~ |\mathsf{txouts}~ pending|}
\end{split}
\end{equation*}

Only the first is expensive. This suggests that we should at least cache the
balance of the UTxO. If we only cache the UTxO then the available and total
balances are not too expensive to compute.

Of course we could cache more, but each extra value we cache adds complexity to
the design, and additional proof obligations.

\subsection{Incrementally maintaining the UTxO balance}
\label{sec:applyBlock_incr}

Let us define a new state $w_\sigma = (utxo, pending, \sigma)$ that contains the UTxO
balance directly. The invariant is of course that $\sigma = \mathsf{balance} ~ utxo$.
Now we must define new function variants $\mathsf{applyBlock}_\sigma$. This is
the only operation that needs non-trivial changes.

For $\mathsf{applyBlock}_\sigma$ we start with a state
$w_\sigma = (utxo, pending, \sigma)$
and we may assume the invariant $\sigma = \mathsf{balance} ~ utxo$.

\begin{equation*}
\begin{split}
\mathsf{applyBlock}_\sigma & ~ b ~ (utxo, pending, \sigma) = (utxo^\prime, pending^\prime, \sigma^\prime) \\
\text{where} \quad \\
    utxo^\prime & = \mathsf{updateUTxO} ~ b ~ utxo \\
    pending^\prime & = \mathsf{updatePending} ~ b ~ pending \\
    \sigma^\prime & = \mathsf{balance} ~ utxo^\prime
\end{split}
\end{equation*}

If we focus on the interesting bits and expand this out a couple steps we get

\begin{equation*}
\begin{split}
    utxo^\prime & = \mathsf{txins} ~ b \subtractdom (utxo \cup (\mathsf{txouts} ~ b \restrictrange \mathsf{TxOut_{ours}})) \\
    \sigma^\prime & = \mathsf{balance} ~ utxo^\prime
\end{split}
\end{equation*}

For convenience we define

\begin{equation*}
\begin{split}
    utxo^+ & = \mathsf{txouts} ~ b \restrictrange \mathsf{TxOut_{ours}} \\
\end{split}
\end{equation*}

And use it, giving us

\begin{equation*}
\begin{split}
    utxo^+ & = \mathsf{txouts} ~ b \restrictrange \mathsf{TxOut_{ours}} \\
    utxo^\prime & = \mathsf{txins} ~ b \subtractdom (utxo \cup utxo^+)  \\
    \sigma^\prime & = \mathsf{balance} ~ (\mathsf{txins} ~ b \subtractdom (utxo \cup utxo^+))
\end{split}
\end{equation*}

Applying lemma \ref{lemma_balance_minus} to distribute $\mathsf{balance}$ over $\subtractdom$ gives us

\begin{equation*}
\begin{split}
    \sigma^\prime & = \mathsf{balance} ~ (utxo \cup utxo^+) - \mathsf{balance} ~ (\mathsf{txins} ~ b \restrictdom (utxo \cup utxo^+)) \\
\end{split}
\end{equation*}

Now it should be a property of the blockchain we can rely on that

\begin{equation*}
\dom utxo \cap \dom (\mathsf{txouts} ~ b) = \emptyset
\end{equation*}

So we can apply the other lemma (equation \ref{lemma_balance_union} to distribute $\mathsf{balance}$ over $\cup$) to give us
\begin{equation*}
\begin{split}
    \sigma^\prime & = \mathsf{balance} ~ utxo + \mathsf{balance} ~ utxo^+ - \mathsf{balance} ~ (\mathsf{txins} ~ b \restrictdom (utxo \cup utxo^+)) \\
             & = \sigma + \mathsf{balance} ~ utxo^+ - \mathsf{balance} ~ (\mathsf{txins} ~ b \restrictdom (utxo \cup utxo^+))
\end{split}
\end{equation*}

In this final step we are able to reuse the previous balance $\sigma$ to
compute the new $\sigma^\prime$ without having to compute
$\mathsf{balance} ~ utxo$ directly.

The extra things we do have to compute turn out not to be expensive
\begin{equation*}
\begin{split}
\mathsf{balance} ~ (\mathsf{txouts} ~ b \restrictrange \mathsf{TxOut_{ours}})  & \in \order{\mathsf{nlogn} ~ |\mathsf{txouts}~ b|} \\
\mathsf{balance} ~ (\mathsf{txins} ~ b \restrictdom utxo) & \in \order{\mathsf{join} ~ |\mathsf{txins}~ b| ~ |utxo|} \\
\end{split}
\end{equation*}

Putting everything back together, and defining $utxo^-$ for symmetry, we get

\begin{equation*}
\begin{split}
\mathsf{applyBlock}_\sigma & ~ b ~ (utxo, pending, \sigma) = (utxo^\prime, pending^\prime, \sigma^\prime) \\
\text{where} \quad \\
    pending^\prime & = \mathsf{updatePending} ~ b ~ pending \\
    utxo^+ & = \mathsf{txouts} ~ b \restrictrange \mathsf{TxOut_{ours}} \\
    utxo^- & = \mathsf{txins} ~ b \restrictdom (utxo \cup utxo^+) \\
    utxo^\prime & = \mathsf{txins} ~ b \subtractdom (utxo \cup utxo^+) \\
    \sigma^\prime & = \sigma + \mathsf{balance} ~ utxo^+ - \mathsf{balance} ~ utxo^- \\
\end{split}
\end{equation*}

\section{Database implementation considerations}
\label{sec:prefiltering}

\subsection{Motivation}

The $\mathsf{applyBlock} ~ b$ operation is problematic in a setting where it is
implemented as an operation on the local database of the wallet and those
operations are stored in a log. The log would contain the full blocks received
by the wallet, which at current constants of a maximum block of 2 MB and a slot
length of 20 seconds would mean a worst-case log growth rate of 360 MB/hour.

\subsection{Derivation}

The goal therefore is to define an auxiliary function to $\mathsf{applyBlock}$
which only needs the ``relevant'' information from the block.
Since $\mathsf{applyBlock}_\sigma$ is only defined in terms of inputs and
outputs of the block, we can easily define the following auxiliary function
(where we have also expanded the definition of $\mathsf{updatePending}$).
%
\begin{equation*}
\begin{split}
\mathsf{applyBlock'}_\sigma & ~ (\mathit{txins}_b, \mathit{txouts}_b) ~ (\mathit{utxo}, \mathit{pending}, \sigma) = (\mathit{utxo}^\prime, \mathit{pending}^\prime, \sigma^\prime) \\
\text{where} \quad \\
    pending^\prime & = \{ tx ~|~ tx \in pending, (inputs, \_) = tx, inputs \cap \mathit{txins}_b = \emptyset \} \\
    utxo^+ & = \mathit{txouts}_b \\
    utxo^- & = \mathit{txins}_b \restrictdom (utxo \cup utxo^+) \\
    utxo^\prime & = \mathsf{txins}_b \subtractdom (utxo \cup utxo^+) \\
    \sigma^\prime & = \sigma + \mathsf{balance} ~ utxo^+ - \mathsf{balance} ~ utxo^- \\
\end{split}
\end{equation*}
%
Letting
%
\begin{math}
\mathit{utxo}^+ = \mathsf{txouts} ~ b \restrictrange \mathsf{TxOut_{ours}}
\end{math}
%
we trivially we have that
%
\begin{equation}
  \mathsf{applyBlock}_\sigma ~ b
= \mathsf{applyBlock}'_\sigma ~ (\mathsf{txins} ~ b, \mathit{utxo}^+)
\end{equation}
%
but we haven't gained much yet because although we only pass in ``our'' outputs,
we still pass in \emph{all} inputs of the block. However, we also have that
%
\begin{equation}
  \mathsf{applyBlock}_\sigma ~ b
= \mathsf{applyBlock}'_\sigma ~ \Big( \mathsf{txins} ~ b \cap \dom (\mathit{utxo} \cup \mathit{utxo}^+), \mathit{utxo}^+ \Bigr)
\end{equation}
%
This reduced set of inputs is sufficient for the definitions of
$\mathit{utxo}^-$ and $\mathit{utxo}^\prime$, since by
Lemma~\ref{restrictdom_dom}
%
\begin{equation*}
  \Bigl( \mathsf{txins} ~ b \cap \dom (\mathit{utxo} \cup \mathit{utxo}^+) \Bigr) \restrictdom (utxo \cup \mathit{utxo}^+) \\
= \mathsf{txins} ~ b \restrictdom (utxo \cup \mathit{utxo}^+)
\end{equation*}
%
and by Lemma~\ref{subtractdom_dom}
%
\begin{equation*}
  \Bigl( \mathsf{txins} ~ b \cap \dom (\mathit{utxo} \cup \mathit{utxo}^+) \Bigr) \subtractdom (utxo \cup \mathit{utxo}^+) \\
= \mathsf{txins} ~ b \subtractdom (utxo \cup \mathit{utxo}^+)
\end{equation*}
%
The reasoning why this reduced set of inputs is \emph{also} sufficient for
the definition of $\mathit{pending}^\prime$ is a bit more subtle:
%
\begin{enumerate}

\item A transaction $\mathit{tx} = (\mathit{inputs}, \mathit{outputs})$ needs to
be removed from $\mathit{pending}$ when one or more of its $\mathit{inputs}$ are
spent by a transaction $\mathit{tx}'$ in the blockchain (perhaps $\mathit{tx} =
\mathit{tx}'$, perhaps not).

\item Transaction $\mathit{tx}'$ can only spent an input $\mathit{\mathit{txin}} =
(\mathit{\mathit{txid}}, ix)$ when the transaction $\mathit{\mathit{txid}}$ that
the input refers to is also available in the blockchain.

\item Moreover, since $\mathit{tx} \in \mathit{pending}$ we must have that
$(\mathit{\mathit{txid}}, ix)$ refers to an output $(\mathit{addr}, c)$
where $\mathit{addr} \in \mathsf{Addr}_\mathsf{ours}$, and hence we must have
$(\mathit{\mathit{txid}}, ix) \mapsto (\mathit{addr}, c)$ in the
$\mathit{\mathit{utxo}}$ of the wallet.

\item When we process blocks as (unordered) \emph{sets} of transactions, there is
one minor complication to this story. In this case, there is one additional
possibility: transaction $\mathit{\mathit{txid}}$ might be in the same block as
$\mathit{tx}$; i.e., it is in $\mathit{utxo}^+$ rather than $\mathit{utxo}$.

\end{enumerate}

You might object that if the wallet isn't aware of transaction
$\mathit{\mathit{txid}}$ yet then $\mathit{tx}$ cannot be in pending, and hence
it should suffice to look at the $\mathit{utxo}$ only. Indeed, invariant
\eqref{txins_in_dom_utxo} tells us that this must be so. In the presence of
rollbacks (Section~\ref{sec:rollback}) this is unfortunately no longer the case,
but the reasoning above continues to be true.

\todo[inline]{It would be nicer if the above could be made more formal; it's
tricky because it involves properties of the blockchain.}

\subsection{Consequences}

The downside is that in order to do this prefiltering we need to know the
current value of our $utxo$, which means we need to do a database read and then
a database write in two separate transactions. While in principle this means
we might suffer from the lost update problem, in practice block updates need to
be processed sequentially \emph{anyway}. It does however impose a proof
obligation on the rest of the system:

\begin{proofobligation}
Only $\mathsf{applyBlock}$ modifies the wallet's UTxO.
\end{proofobligation}

Note that there are at least two possible alternative approaches:

\begin{itemize}
\item The wallet runs as part of a full node, and that full node maintains
the full UTxO of the blockchain. When the fullnode receives a new block,
that block must be consistent with the state of the blockchain, and hence
the fullnode can decorate all inputs with the corresponding addresses before
passing the block to the wallet. This would make the filtering operation in
the wallet trivial and stateless.
\item We can also push the problem further upstream and specify that the
resolved addresses must be listed alongside the transaction IDs in the
transaction inputs themselves. This would effectively be a form of caching
in the blockchain, and may be beneficial elsewhere also.
\end{itemize}

\section{Rollback}
\label{sec:rollback}

The possible presence of forks in the blockchain means that we may occassionally
have to roll back and ``undo'' calls to $\mathsf{applyBlock}$, reverting to an
older version of the UTxO. When we \emph{apply} a block, pending transactions
may become confirmed and are therefore removed from the $\mathit{pending}$ set.
When we roll back, those transactions may once again become pending and should
therefore be reintroduced into $\mathit{pending}$. However, the converse is
\emph{not} true: when we roll back, currently pending transactions will
\emph{remain} pending. After all, those pending transactions may still make it
into the block chain; indeed, may already have made it into the fork that we are
transitioning to. In other words, rolling back may \emph{increase} the size of
the pending set but never decrease it.

\subsection{Specification}
\label{sec:rollback_spec}

Before revisiting performance and prefiltering, let's first consider what
the \emph{specification} of rollback should be.
%
\begin{align*}
& w \in \mathsf{Wallet} = [\mathsf{Utxo} \times \mathsf{Pending}] \\
& \mathsf{applyBlock} ~ b ~ ((\mathit{utxo}, \mathit{pending}) : \mathit{checkpoints}) = \\
& \qquad (( \mathsf{updateUTxO} ~ b ~ \mathit{utxo}
         , \mathsf{updatePending} ~ b ~ \mathit{pending}
         )
         : (\mathit{utxo}, \mathit{pending}) : \mathit{checkpoints}
         ) \\
& \mathsf{newPending} ~ tx ~ ((\mathit{utxo}, \mathit{pending}) : \mathit{checkpoints}) = (\mathit{utxo}, pending \cup \{ tx \} ) : \mathit{checkpoints} \\
& \mathsf{rollback} ~ ((\mathit{utxo}, \mathit{pending}) :  (\mathit{utxo}^\prime, \mathit{pending}^\prime) : \mathit{checkpoints})) =
     (\mathit{utxo}^\prime, \mathit{pending} \cup \mathit{pending}^\prime) : \mathit{checkpoints}
\end{align*}
%
where the side condition to $\mathsf{newPending}$, as well as the definitions
of $\mathsf{updateUTxO}$ and $\mathsf{updatePending}$, remain unchanged.

The wallet state here is a list of \emph{checkpoints}, the value of the wallet
at various times throughout its lifetime; each call to $\mathsf{applyBlock}$
introduces a new checkpoint. The initial wallet is the singleton list
%
\begin{equation}
\begin{split}
w_\emptyset & \in \mathsf{Wallet} \\
w_\emptyset & = [(\emptyset, \emptyset)]
\end{split}
\end{equation}
%
We cannot roll back a wallet that contains only a single checkpoint
(this would anyway not make semantic sense).


\begin{lemma}
\begin{equation*}
\mathsf{rollback} \circ \mathsf{applyBlock} ~ b = \mathsf{id}
\end{equation*}
\end{lemma}

\begin{proof}
\begin{align*}
    & \mathsf{rollback} ~ (\mathsf{applyBlock} ~ b ~ ((\mathit{utxo}, \mathit{pending}) : \mathit{checkpoints})) \\
= ~ & \mathsf{rollback} ~ (( \mathsf{updateUTxO} ~ b ~ \mathit{utxo}
         , \mathsf{updatePending} ~ b ~ \mathit{pending}
         )
         : (\mathit{utxo}, \mathit{pending}) : \mathit{checkpoints}
         ) \\
= ~ & (\mathit{utxo}, (\mathsf{updatePending} ~ b ~ \mathit{pending}) \cup \mathit{pending}) : \mathit{checkpoints} \\
= ~ & (\mathit{utxo}, \mathit{pending}) : \mathit{checkpoints}
\end{align*}
\end{proof}

The last line is justified by Lemma~\ref{lemma:updatePending_is_filter}.

\begin{lemma} \label{lemma:updatePending_is_filter}
\begin{equation*}
\mathsf{updatePending} ~ b ~ \mathit{pending} \subseteq \mathit{pending}
\end{equation*}
\end{lemma}

Moreover, we have

\begin{lemma}
\begin{equation*}
\mathsf{rollback} \circ \mathsf{newPending} ~ tx \circ \mathsf{applyBlock} ~ b
= \mathsf{newPending} ~ tx
\end{equation*}
(modulo checking side conditions).
\end{lemma}

\begin{proof}
\begin{align*}
    & \mathsf{rollback} ~ (\mathsf{newPending} ~ tx ~ (\mathsf{applyBlock} ~ b ~ ((\mathit{utxo}, \mathit{pending}) : \mathit{checkpoints}))) \\
= ~ & \mathsf{rollback} ~ (\mathsf{newPending} ~ tx ~ (( \mathsf{updateUTxO} ~ b ~ \mathit{utxo}
         , \mathsf{updatePending} ~ b ~ \mathit{pending}
         )
         : (\mathit{utxo}, \mathit{pending}) : \mathit{checkpoints}
         )) \\
= ~ & \mathsf{rollback} ~ (( \mathsf{updateUTxO} ~ b ~ \mathit{utxo}
         , (\mathsf{updatePending} ~ b ~ \mathit{pending}) \cup \{tx\}
         )
         : (\mathit{utxo}, \mathit{pending}) : \mathit{checkpoints}
         ) \\
= ~ & (\mathit{utxo}, ((\mathsf{updatePending} ~ b ~ \mathit{pending}) \cup \{tx\}) \cup \mathit{pending}) : \mathit{checkpoints} \\
= ~ & (\mathit{utxo}, \mathit{pending} \cup \{tx\}) : \mathit{checkpoints}
\end{align*}
\end{proof}

where the last line follows from Lemma~\ref{lemma:updatePending_is_filter} and
associativity and commutativity of set union.

\subsection{Invariants}

The most important consequence of introducing rollbacks is that invariant
\eqref{txins_in_dom_utxo}, which states that
%
\begin{equation*}
\mathsf{txins} ~ pending \subseteq \dom utxo
\end{equation*}
%
may now be violated. This needs careful consideration.

First, we were using this invariant as an indirect way of stating that there
can be no ``dependent'' transactions (Section~\ref{sec:invariants}). We can
state this more directly as
%
\begin{equation} \label{no_dep_trans}
\mathsf{txins} ~ \mathit{pending} \cap \dom (\mathsf{txouts} ~ \mathit{pending}) = \emptyset
\end{equation}
%
Sadly, this property too may no longer hold after a rollback. This is expected;
consider the following chain of events:
%
\begin{enumerate}
\item The user submits transaction $t_1$, and $t_1$ gets confirmed.
\item They then submit transaction $t_2$, which uses an output of transaction as $t_1$ as input.
\item Finally, we roll back. We end up with both transactions $t_1$ and $t_2$ as pending, with $t_2$ dependent on $t_1$.
\end{enumerate}

If we wanted to avoid this, we would have to strenghten the side condition to
$\mathsf{newPending}$:

\begin{itemize}
\item Confirmed transactions can only be used as inputs once we are absolutely
certain that the blockchain will not roll back so far that they become pending
again. (This is sufficient to guarantee \eqref{no_dep_trans}.)
\item \emph{Incoming} transactions should also not be used until we are guaranteed
that the chain will not rollback past where they were confirmed. (Necessary to
additionally guarantee \eqref{txins_in_dom_utxo}.)
\end{itemize}

In other words, both transactions submitted by the wallet itself and
transactions from other wallets to this wallet can only be used after $k$ slots.
With the security parameter $k$ set to 2160 and a slot length of 20 seconds,
this currently takes exactly 12 hours. This is probably too restrictive.

The remainder of the invariants of Section~\ref{sec:invariants} continue to hold.

\subsection{Available and change}

The definition of $\mathsf{available}$ can remain unchanged
%
\begin{equation}
  \mathsf{available} ~ ((\mathit{utxo}, \mathit{pending}) : \mathit{checkpoints})
= \mathsf{txins} ~ \mathit{pending} \subtractdom \mathit{utxo} \\
\end{equation}
%
It makes no difference if  $\mathit{pending}$ contains
inputs that don't exist in the UTxO (this is a direct consequence of
lemma \eqref{subtractdom_dom}).

In the presence of dependent transactions, however, the definition of
$\mathsf{change}$ needs to be modified, since we should not include any
transaction outputs that are consumed by other pending transactions:
%
\begin{equation*}
  \mathsf{change} ~ ((\mathit{utxo}, \mathit{pending}) : \mathit{checkpoints})
= \mathsf{txins} ~ \mathit{pending} \subtractdom (\mathsf{txouts} ~ \mathit{pending} \restrictrange \mathsf{TxOut_{ours}})
\end{equation*}
%
(This change could be avoided if we strenghten the side condition to
$\mathit{newPending}$, as discussed in the previous section.)

The remainder of the definitions from Section~\ref{sec:wallet_operations} can
remain unchanged, with the side condition to $\mathsf{newPending}$ continuing to
ensure that we cannot introduce any \emph{new} dependent pending transactions.
This is still useful for keeping the number of dependent transactions down.

\subsection{Missing inputs}

In the presence of rollbacks the interpretation of $\mathsf{change}$ (and
consequently of $\mathsf{total}$) becomes a bit more subtle, and we should be
careful with how we present it the user. Consider the following situation:
%
\begin{enumerate}
\item In block $b$ a user receives a large sum of money through transaction
$t_1$.
\item The user then submits a transaction $t_2$ that transfers a small
percentage of that large sum to someone else. At this point $\mathsf{change}$
would be a large figure.
\item If we now roll back block $b$, we end up with a UTxO in
which the user never received the large sum of money in the first place, but
$\mathsf{change}$ is \emph{still} large.
\end{enumerate}

This is not incorrect: it is still true that \emph{if and when} $t_2$ gets
included into the blockchain, transaction $t_1$ must also have been; but this is
somewhat tentative. Put another way, $\mathsf{change}$ may now anticipate
transfers \emph{to} the user that have not yet happened.

We can calculate the total $\mathsf{expected}$ value of these $\mathsf{missing}$
inputs, but we have to do so in a slightly roundabout way. The missing inputs
are given by
%
\begin{equation*}
\mathsf{missing} ~ (\mathit{utxo}, \mathit{pending})
= (\mathsf{txins} ~ \mathit{pending}) \setminus
(\mathsf{txins} ~ \mathit{utxo} \cup \mathsf{txins} ~ (\mathsf{txouts} ~ \mathit{pending}))
\end{equation*}
%
but we cannot use that to find their $\mathsf{expected}$ value: since these
missing inputs refer to transactions (by hash) that we haven't received yet,
we don't know what their corresponding outputs are. However, we \emph{do}
know the total value of the inputs we \emph{do} have; so, we can take advantage
of the property that transactions must be value preserving and define
$\mathsf{expected}$ as
%
\begin{align*}
  & ~ \mathsf{expected} ~ (\mathit{utxo}, \mathit{pending}) \\
= & ~ \mathsf{balance} (\mathsf{txins} ~ \mathit{pending} \restrictdom \mathit{utxo}) \\
- & ~ \mathsf{balance} (\mathsf{txins} ~ \mathit{pending} \restrictdom \mathsf{txouts} ~ \mathit{pending})
\end{align*}
%
Alternatively, for a transaction in $\mathit{pending}$ to have a missing input,
that particular input must have been in the UTxO of the wallet \emph{at some
point}. So we should have the following invariant:

\begin{invariant}[$\mathsf{expected}$ vs $\mathsf{missing}$]
Given a wallet $((\mathit{utxo}, \mathit{pending}) : \mathit{checkpoints})$,
we must have that
\begin{equation*}
  ~ \mathsf{expected} ~ (\mathit{utxo}, \mathit{pending})
= \mathsf{missing} ~ (\mathit{utxo}, \mathit{pending}) \restrictdom \left( \mathit{utxo} \cup \bigcup_{(\mathit{utxo}', \textunderscore) \in \mathit{checkpoints}} \mathit{utxo}' \right)
\end{equation*}
\end{invariant}

Note that this invariant is only true if the only source of dependent transactions
is rollbacks; if we allow the user to introduce new dependent transactions,
this invariant must be modified.

It is of course possible that such missing transactions (like $t_1$ in the
example above) \emph{never} make it into the new fork, in which case the user's
transaction ($t_2$) should eventually be removed from $\mathit{pending}$. This
problem may arise even without rollbacks, however, and cannot be solved until we
introduce a TTL value for transactions.

\subsection{Reporting}
\label{sec:reporting}

The question of which balance the wallet reports to the user depends on how
much uncertainly is acceptable in that number.

\begin{itemize}
\item Simply reporting $\mathsf{totalBalance}$ assumes that all pending
transactions will eventually make it into the blockchain.
\item Reporting the $\mathsf{available}$ and $\mathsf{change}$ balance separately
assumes that there are no $\mathsf{missing}$ transactions or that they will
eventually make it into the blockchain.
\item Reporting $\mathsf{available}$, $\mathsf{change}$ and $\mathsf{expected}$
balance based on the most recent block will them ``jump'' more frequently
when there are rollbacks. (Rollbacks are very infrequent in Ouroboros,
but are expected to be somewhat more common in Ouroboros Praos.)
\end{itemize}

The most conversative therefore seems to be to report all of
$\mathsf{available}$, $\mathsf{change}$ and $\mathsf{expected}$, based on the
state of the wallet some $1 < n \ll k$ slots back (perhaps instead of,
perhaps in addition to, the values based on the most recent wallet state).

\subsection{Switching to a fork}

Although $\mathsf{rollback}$ is a useful primitive operation on the wallet
state, in practice the wallet will never ever actually rollback, but rather
switch to a different fork. The disambiguation rule in the underlying blockchain
protocol (either Ouroboros or Ouroboros Praos) states that this can only happen
if that other fork is \emph{longer} than the current one.

It will therefore we useful to provide a higher-level operation that combines
rolling back with applying the blocks in the new fork:

\begin{equation}
\mathsf{switch} ~ n ~ \mathit{blocks} = \mathsf{applyBlocks} ~ \mathit{blocks} \circ \mathsf{rollbacks} ~ n
\end{equation}

where $\mathsf{rollbacks} ~ n$ calls $\mathsf{rollback}$ $n$ times, and
$\mathsf{applyBlocks}$ calls $\mathsf{applyBlock}$ for all blocks in order.
Such an operation is important because it means that the intermediate state
of the wallet during the switch is not visible to the user; this will also
help with the balance jumping problem mentioned in Section~\ref{sec:reporting}.

\emph{Implementation Note.} The current Cardano API does not provide something
equivalent to $\mathsf{switch}$, instead providing only hooks that correspond to
$\mathsf{applyBlocks}$ and $\mathsf{rollbacks}$. The wallet kernel however could
batch up the calls to $\mathsf{rollbacks}$, and not apply the $n$ rollbacks
until it has at least $n + m$ ($m \ge 1$) blocks to apply. This solution is not
ideal, as it is unclear what value to set $m$ to; probably the only workable
solution is to set a time bound. However, since all these $\mathsf{applyBlocks}$
will come very close together (\emph{maybe} even as a single call), in practice
this can probably work reasonably well.

\subsection{Memory requirements}

Obviously, storing all checkpoints of the UTxO leads to unbounded memory usage.
Thankfully however the blockchain protocol defines a ``security parameter'' $k$
which guarantees that we will never have to roll back past $k$ slots, and hence
don't have to store more than $k$ checkpoints. Currently, $k$ is set to 2160;
for a typical user, the UTxO and pending sets will not be large and keeping
track of the last 2160 values will not be a huge deal.

\todo[inline]{We should state this formally: define a version of the wallet
that keeps only $k$ checkpoints and prove that all properties we're interested
in still hold, given the assumption that we will never roll back more than
$k$ slots.}

We can also give a more precise upper bound on the memory requirements. Instead
of storing $k$ UTxO checkpoints, it would also suffice to store the UTxO as it
was $k$ slots ago, and store all $k$ blocks since the last checkpoint. Since a
block has a maximum size of 2 MB, this means we need to store at most a little
over 4 GB of data.

As far as the pending transactions go, with the conservative estimate of 100
pending transactions per slot, it'd be a maximum 216,000 transactions (plus some
administrative overhead). At a maximum transaction size of 64 kB, this adds an
additional 13.5 GB; however, at more typical values of 3 pending transactions
this reduces to 405 MB, and with a more typical average transaction size of 4
kB, to a mere 25 MB.

Since rollbacks are relatively rare (especially having to roll back far), it
would be fine to store this information on disk rather than in memory, and hence
these memory requirements are no big deal at all. Probably the best engineering
trade-off will be to store a few checkpoints in memory and the rest on disk.

\todo[inline]{Check storage requirements with persistent data structures and sharing,
should be something like a log cost for each change}

\subsection{Incremental balance computation and prefiltering}

Neither the derivation of the incremental balance computation nor the derivation
of prefiltering relied on invariant~\eqref{txins_in_dom_utxo} (although we did
have to be careful in derivation of prefiltering); this means that their
definitions translate in a straight-forward manner to this new setting in which
rollbacks may be present. The type of the wallet becomes
%
\begin{equation*}
\mathsf{Wallet} = [\mathsf{Utxo} \times \mathsf{Pending} \times \mathsf{Coin}]
\end{equation*}
%
The definition of $\mathsf{applyBlock}'_\sigma$ then remains pretty much the
same, except that it stores the old UTxO as a checkpoint:

\begin{equation*}
\begin{split}
\mathsf{applyBlock}'_\sigma & ~ (\mathit{txins}_b, \mathit{txouts}_b) ~ ((\mathit{utxo}, \mathit{pending}, \sigma) : \mathit{checkpoints}) = \\
& ((utxo^\prime, pending^\prime, \sigma^\prime), (\mathit{utxo}, \mathit{pending}, \sigma) : \mathit{checkpoints}) \\
\text{where} \quad \\
    pending^\prime & = \{ tx ~|~ tx \in pending, (inputs, \_) = tx, inputs \cap \mathit{txins}_b = \emptyset \} \\
    utxo^+ & = \mathit{txouts}_b \\
    utxo^- & = \mathit{txins}_b \restrictdom (utxo \cup utxo^+) \\
    utxo^\prime & = \mathsf{txins}_b \subtractdom (utxo \cup utxo^+) \\
    \sigma^\prime & = \sigma + \mathsf{balance} ~ utxo^+ - \mathsf{balance} ~ utxo^- \\
\end{split}
\end{equation*}

Rollback now needs to restore the cached balance along with the UTxO, and the
invariant that the cached balance matches the balance computed over the UTxO
now extends to each checkpoint. The lemmas from Section~\ref{sec:rollback_spec}
should extend to this modified definition without difficulty.

\section{Minimum Balance}

\todo[inline]{Merge this with the rest of the document}

\begin{definition}[Minimum balance]
The wallet's \emph{minimum balance} is the minimum balance the wallet may have
in any possible future, assuming the owner of the wallet does not submit any
new transactions.
\end{definition}

\todo[inline]{Make this more formal.}

Of course, if the wallet's owner can submit further transactions, then the
minimum balance of the wallet is simply zero (the owner spends all their
funds). For somewhat similar reasons, the wallet's \emph{maximum} balance
is not a particular interesting notion; if we stipulate ``assuming no
incoming transactions'' then the maximum balance is simply the current balance,
and if we don't make such a stipulation, then the balance of the wallet is
unbounded (or bounded by the cryptocurrency's cap).

\subsection{Basic Model}

Given a wallet $(\mathit{utxo}, \mathit{pending})$, the wallet's minimum balance
is given by

\begin{align*}
  & ~ \mathsf{minBalance} ~ (\mathit{utxo}, \mathit{pending}) \\
= & ~ \mathsf{balance} ~ \mathit{utxo}
    - \mathsf{balance} ~ (\mathsf{txins} ~ \mathit{pending} \restrictdom \mathit{utxo})
    + \mathsf{balance} ~ (\mathsf{txouts} ~ \mathit{pending} \restrictrange \mathsf{TxOut}_\mathsf{ours}) \\
= & ~ \mathsf{totalBalance} ~ (\mathit{utxo}, \mathit{pending})
\end{align*}

\begin{proof}[Proof (sketch)]
Since the wallet's owner is not submitting any new transactions, transactions
created by \emph{other} entities cannot transfer funds out of the wallet.
Moreover, all of the pending transactions \emph{decrease} the
wallet's balance, so the wallet's minimum balance will be reached when all
of those pending transactions are included in the blockchain.
\end{proof}

\subsection{Dependent transactions}

When we allow for dependent transactions, the situation is much the same as
for the basic model, but we need to make sure that we don't add any ``change''
outputs that are spent within $\mathit{pending}$.

\subsection{Rollback}

Rollback makes the situation more subtle. We have a set $\mathit{pending}$
of transactions that the wallet's owner submitted, but have not yet been
included in the blockchain, as well as a set $\mathit{expected}$ of transactions
that transfer funds \emph{to} the wallet, but also have not yet been included
in the blockchain.

If these expected and pending transactions would all be independent, the
minimum balance of the wallet would simply be given by assuming that none of
the expected transactions get confirmed and all of the pending ones do.
Unfortunately, there can (and will) be dependencies between these two sets
in both directions.

Observations:

\begin{itemize}
\item Consider a pending transaction $t$ (i.e., a transaction that decreases
the wallet's balance). Provided that all of $t$'s dependencies are included,
then we should \emph{always} include $t$: if nothing depends on $t$, then
including $t$ will obviously decrease the wallet's balance; if there are
other transactions that depend on $t$, then \emph{not} including $t$ will
mean we get no choice in including those other transactions or not, but
if we do include it, it doesn't force our hand either way for those
other transactions.
\end{itemize}




\begin{figure}[p]

\newcommand{\Y}[1]{#1}
\newcommand{\N}[1]{\overline{#1}}

\begin{tabular}{lll}
%%%
\multicolumn{3}{l}{\emph{Single independent tranasction}} \\
\begin{forest}
[$(t_1: c_1)$]
\end{forest}
&
\begin{math}
\Delta =
\begin{cases}
   0 & \overline{t_1} \\
 c_1 & t_1
\end{cases}
\end{math}
&
include if $c_1 \le 0$
\\
%%%
\\
\multicolumn{3}{l}{\emph{One transaction dependent on one other}} \\
\begin{forest}
[$(t_1: c_1)$, baseline [$(t_2: c_2)$]]
\end{forest}
&
\begin{math}
\Delta =
\begin{cases}
0         & \N{t_1} \, \N{t_2} \\
c_2       & \N{t_1} \, \Y{t_2} \\
c_2 + c_1 & \Y{t_2} \, \Y{t_2}
\end{cases}
\end{math}
&
\begin{math}
\begin{array}{ll|l}
c_2 &                    & \text{pick}        \\ \hline
< 0 &                    & \Y{t_1} \, \Y{t_2} \\
> 0 & c_1 + c_2 \le 0    & \Y{t_1} \, \Y{t_2} \\
    & \textit{otherwise} & \N{t_1} \, \N{t_2} \\
\end{array}
\end{math} \\
&& $t_1$ never included if $c_1 > 0$ \\
\\
%%%
\\
\multicolumn{3}{l}{\emph{One transaction dependent on two others}} \\
\begin{forest}
[$(t_1: c_1)$ [$(t_2: c_2)$] [$(t_3: c_3)$]]
\end{forest}
&
\begin{math}
\Delta =
\begin{cases}
0               & \N{t_1} \, \N{t_2} \, \N{t_3} \\
c_3             & \N{t_1} \, \N{t_2} \, \Y{t_3} \\
c_2             & \N{t_1} \, \Y{t_2} \, \N{t_3} \\
c_3 + c_2       & \N{t_1} \, \Y{t_2} \, \Y{t_3} \\
c_3 + c_2 + c_1 & \Y{t_1} \, \Y{t_2} \, \Y{t_3}
\end{cases}
\end{math}
&
\begin{math}
\begin{array}{lll|l}
c_2 & c_3 &                         & \text{pick} \\ \hline
< 0 & < 0 &                         & \Y{t_1} \, \Y{t_2} \, \Y{t_3} \\
< 0 & > 0 & c_1 + c_3 \le 0         & \Y{t_1} \, \Y{t_2} \, \Y{t_3} \\
    &     & \textit{otherwise}      & \N{t_1} \, \Y{t_2} \, \N{t_3} \\
> 0 & < 0 & c_1 + c_2 \le 0         & \Y{t_1} \, \Y{t_2} \, \Y{t_3} \\
    &     & \textit{otherwise}      & \N{t_1} \, \N{t_2} \, \Y{t_3} \\
> 0 & > 0 & c_1 + (c_2 + c_3) \le 0 & \Y{t_1} \, \Y{t_2} \, \Y{t_3} \\
    &     & \textit{otherwise}      & \N{t_1} \, \N{t_2} \, \N{t_3} \\
\end{array}
\end{math}
\\
&& (if $c_1 > 0$ reduces to two independent transactions.)
\\
%%%
\\
\multicolumn{3}{l}{\emph{Two transactions depending on a single other}} \\
\begin{forest}
  [,phantom
  [$(t_1: c_1)$ [$(t_3: c_3)$, name=t3]]
  [$(t_2: c_2)$] {\draw () to (t3);}
  ]
\end{forest}
&
\begin{math}
\Delta =
\begin{cases}
0               & \N{t_1} \N{t_2} \N{t_3} \\
c_3             & \N{t_1} \N{t_2} \Y{t_3} \\
c_3 + c_2       & \N{t_1} \Y{t_2} \Y{t_3} \\
c_3 + c_1       & \Y{t_1} \N{t_2} \Y{t_3} \\
c_3 + c_2 + c_1 & \Y{t_1} \Y{t_2} \Y{t_3}
\end{cases}
\end{math}
&
\begin{math}
\begin{array}{ll|l}
c_3 &                         & \text{pick}             \\ \hline
< 0 &                         & \Y{t_1} \Y{t_2} \Y{t_3} \\
> 0 & (c_1 + c_2) + c_3 \le 0 & \Y{t_1} \Y{t_2} \Y{t_3} \\
    & \textit{otherwise}      & \N{t_1} \N{t_2} \N{t_3} \\
\end{array}
\end{math} \\
&& $t_1$ never included if $c_1 > 0$; similarly for $t_2$
\\
%%%
\\
\multicolumn{3}{l}{\emph{Common ancestor}} \\
\begin{forest}
[$(t_1: c_1)$
  [$(t_2: c_2)$, baseline [$(t_4: c_4)$, name=t4]]
  [$(t_3: c_3)$] {\draw () to (t4);}
]
\end{forest}
&
\begin{math}
\Delta =
\begin{cases}
0                     & \N{t_1} \N{t_2} \N{t_3} \N{t_4} \\
c_4                   & \N{t_1} \N{t_2} \N{t_3} \Y{t_4} \\
c_4 + c_3             & \N{t_1} \N{t_2} \Y{t_3} \Y{t_4} \\
c_4 + c_2             & \N{t_1} \Y{t_2} \N{t_3} \Y{t_4} \\
c_4 + c_3 + c_2       & \N{t_1} \Y{t_2} \Y{t_3} \Y{t_4} \\
c_4 + c_3 + c_2 + c_1 & \Y{t_1} \Y{t_2} \Y{t_3} \Y{t_4}
\end{cases}
\end{math}
\end{tabular}







\end{figure}

\clearpage


\section{TODO: History tracking}

Goals:

\begin{itemize}
\item For each transaction ever submitted to the wallet, or coming from the
blockchain and transferring funds to the wallet, be able to report its current
state: pending, confirmed (and how deep into the chain it was confirmed),
abandoned.
\item Support efficient storage.
\item Support fast lookup (and pagination).
\end{itemize}

Non-goal: be able to see when things rolled back; but can of course use
implement the above as a view on some sort of append-only log
(as long as efficiency is guaranteed).

\section{TODO: Transaction resubmission}

Exponential back-off?

Give up after 1 hr? (Currently applied heuristic in lieu of a proper TTL.)

\section{TODO: Transaction input selection and UTxO maintenance}

\subsection{The problems}

Let us start by identifying the problems.

Selecting transaction inputs is non-trivial because of transaction fees and
because there are multiple competing goals. In a myopic view of input
selection, the distribution of coins across available inputs is assumed to be
fixed, or to be out of our control, whereas in reality we can -- at some cost
-- actively adjust the distribution.

In general the problem should be considered as optimising for certain goals
over long sequences of incoming and outgoing transactions. In this setting
the input selection and active UTxO maintenance are parts of a single policy.
To evaluate a policy we should consider scenarios, such as: steady states with
assumed distributions of values of incoming transactions and outgoing
transactions; very large payments; or emptying a wallet.

\subsection{Input selection}

The problem with fees is that the minimum fee depends on the size of the transaction
-- currently the size in bytes of the serialised representation -- but paying a
fee may require selecting more transaction inputs which increases the size.

\begin{equation}
\begin{split}
\mathsf{minfee} & \in \mathsf{Tx} \to \mathsf{Coin} \\
\mathsf{minfee} & = f \circ \mathsf{size} \circ \mathsf{serialise} \\
             & \text{where } f \text{ is some linear function}
\end{split}
\end{equation}

The actual fee for a specific transaction must be at least the minimum fee of
course. There is no fee upper bound but a ``good'' input selection
implementation will produce a relatively tight bound. We may wish to make that
tight bound precise such as constraining it to be within a certain factor of
the minimum fee.

\begin{equation}
\begin{split}
\mathsf{fee} ~ utxo ~ tx \geq \mathsf{minfee} ~ tx
\end{split}
\end{equation}

The fee itself is not represented explicitly in the transaction, it is a
function of the current UTxO.

\begin{equation}
\begin{split}
\mathsf{fee} & \in \mathsf{UTxO} \to \mathsf{Tx} \to \mathsf{Coin} \\
\mathsf{fee} ~ utxo ~ tx & = \mathsf{totalin} ~ utxo ~ tx - \mathsf{totalout} ~ tx
\end{split}
\end{equation}
%
\begin{equation}
\begin{split}
\mathsf{totalin} ~ utxo ~ (inputs, ~ \_) & = \mathsf{balance} ~ (inputs \restrictdom utxo) \\
                 & \text{if } inputs \subseteq \dom utxo \\
\mathsf{totalout} ~ (\_, ~ outputs) & = \sum_{(\_, c) \in outputs} c \\
\end{split}
\end{equation}

Thus fee calculation and input selection are interdependent. There are
situations where it is not immediately obvious that there is a terminating
algorithm for selecting inputs and fees optimally.

Input selection can also have multiple goals, including: minimising fees,
cryptographic security, maximising privacy and allowing high throughput. Of
course there is always the issue of acceptable time and space complexity.

The goal of minimising fees is obvious, but it is immediately plausible to see
that other goals may be in conflict since they may require picking other or
additional inputs. The goal of minimising fees highlights the fact that input
selection is not a single-shot problem. Minimising the fee of a single
transaction is not the same as minimising fees in the long term over a
sequence of transactions drawn from a distribution of transaction sizes.

The cryptographic security goal comes from the observation that once an input
at an address has been spent from, its public key is publicly known and is
arguably no longer suitable for very long term storage of funds due to the
evolution of cryptography. The standard solution with input selection is to add
a constraint that if we pick one input then we must pick all other inputs that
were output to the same address. This results in no more funds remaining at the
address (assuming an address non-reuse strategy such that there are no later
payments to that address).

The privacy goal is to make it impractical for other people observing the
transactions in the ledger to tie an identity to all the funds belonging to
that identity. In UTxO style accounting, this is typically done by an identity
holding multiple unspent transaction outputs and avoiding using them in such a
way that they can be easily associated with each other. For example, an obvious
thing to avoid is having different unspent transaction outputs at the same
address. One particular issue is the problem of the ``change address'' in a
transaction being easily identifiable. For example, if a very large input is
selected and a small amount is sent to one output and the remaining large
amount to another output then all observers will reasonably conclude that the
large output is the change address. Tracing transaction graphs with lots of
easy signs like this makes it much easier to

Achieving a high rate of transactions in a UTxO style ledger involves having
multiple unconfirmed transactions in-flight at once. There are hazards with
dependent in-flight transactions so to avoid them it is preferable to construct
independent transactions. For input selection this means not picking change
addresses of unconfirmed transactions. For UTxO maintenance this implies that
we must maintain a large enough supply of suitable unspent outputs. This is in
contrast to UTxO distributions that concentrate most funds in a small number of
unspent outputs.

\subsection{UTxO maintenance}

We will consider two basic use cases: exchanges and individual users. We will
see that the two use cases need policies that aim for different goals, so we
will look to design a policy for each use case.

We assume that exchanges have high rates of incoming and outgoing transactions,
large overall balances and will tend to have large UTxOs. For this use case we
are concerned with asymptotic complexity (due to the large UTxO) and have a
goal of high throughput, but we are not overly concerned with the goals of
achieving privacy or minimising fees. Exchanges tend to follow deposit policies
which are incompatible with the cryptographic security goal as described above,
so this is not a goal of the policy.

For individual users we assume a low rate of incoming and outgoing transactions
and a comparatively small UTxO. For this use case we are not too concerned with
asymptotic complexity as the UTxO is assumed to be small, nor with a goal of
high throughput. We are concerned with the privacy goal, as individual users
are able to use their wallets in a way that preserves a degree of privacy. We
are somewhat concerned with keeping fees reasonably low.

There is another goal we may wish to consider for the individual user use case:
preserving the ability to spend all or a large fraction of the total balance in
a wallet. A similar property for an exchange wallet would be maintaining the
ability to make payments up to a certain size (or fraction of the overall
balance).

\subsection{Basic specification of input selection}

Ignoring the issues of optimising for various goals, we start with the basic
problem definition and conditions on a valid solution.

Given a wallet's available UTxO and a bunch of output addresses and corresponding
amounts, pick a set of inputs and outputs to form the transaction.

\begin{equation}
\begin{split}
\mathsf{selectInputs} \in \mathsf{UTxO} \to (\mathsf{Ix} \mapsto \mathsf{TxOut})
                      \to (\powerset{\mathsf{TxId}} \times (\mathsf{Ix} \mapsto \mathsf{TxOut}))
\end{split}
\end{equation}
Obviously the inputs selected must be ones that are available in the UTxO and
the outputs requested have to be included in the outputs chosen. Additionally,
the outputs may contain change outputs and of course these must be our own
addresses so the change goes back to our wallet. And of course we must pay
transaction fees.
\begin{equation}
\begin{split}
(inputs, outputs^\prime) & = \mathsf{selectInputs} ~ utxo ~ outputs \\
outputs_{change} & = outputs^\prime \setminus outputs \\
 \Longrightarrow \quad & inputs ~ \subseteq \dom utxo \\
\wedge & ~ outputs \subseteq outputs^\prime \\
\wedge & ~ outputs_{change} \subseteq \mathsf{TxOut_{ours}} \\
\wedge & ~ \mathsf{minfee} ~ tx \leq \mathsf{fee} ~ utxo ~ (inputs, output^\prime) \leq \mathsf{minfee} ~ tx \times C\\
\end{split}
\end{equation}

\subsection{A plausible approach}

Suppose we take a UTxO relation set and arrange it into buckets based on the
coin value. We declare buckets based on powers of two, so that bucket $j$
contains inputs with coin values $c$ in the range $2^j \leq c < 2^{j+1}$. This
gives us a logarithmic number of buckets. The intuition is that if we are able
to be indifferent between unspent outputs within each bucket, then we can
select an input of any size in log time.

For basic input selection, suppose initially that there are enough unspent
outputs in each bucket, and we are trying to spend a total output (including
fees) of $2^j \leq c < 2^{j+1}$. We pick \emph{two} inputs from bucket $j$,
giving us a total output value of $2^{j+1} \leq v < 2^{j+2}$. Thus $c \leq v$.

For fees, we can derive a worst case fee formula based only on the number of
inputs and outputs. So in a typical case we can compute the worst case fee up
front and include it in the total output we are trying to spend. As a later
step we should be able to minimise the fee (computed using the actual inputs
and outputs) and shift the excess into the change address(es). It is not
essential to achieve the minimum fee, provided we can achieve a reasonable
bound in a reasonable time.

If there are not enough available inputs in the target bucket we need to have
a worst-case algorithm. This may be as follows: look for one input in higher
buckets in ascending order. If there are none, iterate over the list of buckets
from highest value to smallest, taking the total balance and size of each bucket
and accumulating a running total. And outcome is obviously possible if the total
balance (plus worst case fees) goes over the target output before the number of
inputs makes the transaction size bigger than the maximum. If both limits are
breached by adding a single bucket then it becomes necessary to sort the bucket
and do the same linear search within the bucket. In a typical case this takes
log time, but in the worst case it is n log n in the size of the offending
bucket, which in the worst case contains the entire UTxO.

In the typical case that there were enough available inputs in the target
bucket then we have not used many inputs and we should take the opportunity
to do some UTxO maintenance.

We assume we can define a policy target function which gives the ideal number
of entries in each UTxO bucket. This may be a function of the total UTxO
balance and it is likely sensible to have a parameters for lower and upper
limits on bucket size (very small inputs are not very useful, while very big
ones take up too much balance).

UTxO maintenance then consists of evaluating the function on each bucket and
seeing which buckets are above or below the ideal. The ideal function may be
real valued but of course buckets contain an integer number of entries. We
should use a threshold to avoid unnecessary movement, and at a minimum 1. Once
we know which buckets are too full or not full enough, we move entries from
buckets that are too full towards ones that are not full enough. There are of
course many ways to do this so one plausible approach is to establish some
order on how desirable each one is, and then pick in order, up to some limit
(again ultimately limited by the transaction size).

To avoid excessive UTxO rearrangement we should evaluate the use of the
threshold of how much a bucket is above or below the ideal, and/or use some
measure of how far the UTxO deviates from the ideal distribution to decide
how aggressively we should rearrange. Then this should be evaluated in
simulations over time.

\section{TODO: Persistent storage}

Threading (see prefiltering)

Batching (see rollback, definition of $\mathsf{switch}$).

\section{TODO: Lightweight wallet}

Stateless client (containing keys only) with server-side wallet state
(one server supporting multiple wallets).

\section{TODO: Wallet recovery}

Efficient wallet recovery

Also very important for the design of the light-weight wallet, where we may
spin up and tear down wallets very frequently.

\section{Next steps}

Consider rollbacks.

Consider confirmations / block depth.

Consider address selection, both how to do it and what information may need to
be maintained (incrementally) to do it efficiently. Partly this can be specified
and partly it needs to be simulated to establish the emergent behaviour over a
long series of transactions.

Look for other properties, e.g. wallet utxo $\subseteq$ chain utxo.

Establish storage/memory requirements.

It should be true that different instances of the "same" wallet (that do not share their pending sets) eventually end up in the same state.

Add pending tx expiry / TTL (would be needed to prove wallets end up in the same state after a finite time).

Prove properties.

\bibliographystyle{apalike}
\bibliography{references}

\end{document}
